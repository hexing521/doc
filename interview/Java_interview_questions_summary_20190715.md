
### 多线程
#### CPU核心数、线程数的关系
    
    Cpu核心数可以理解为逻辑上模拟出的核心数；  
    线程数个数=cpu个数*cpu核心数*超线程数
     
#### 在CPU时间片轮转机制中设置多少毫秒是合理的？

#### 什么是进程？什么是线程？一个进程最多可以创建多少个线程？
    
    进程是系统进行资源分配和调度的一个独立单元；    
    线程是进程的实体，是cpu资源分配和调度的最小单元，线程本身不拥有资源，它只拥有一些运行时所需要的资源（寄存器，栈，程序计数器等）,    
    它可与同属同一个进程的其他线程共享进程所拥有的所有资源;  
    默认情况下，一个线程的栈要预留1M的内存空间,而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程,  
    但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。

#### 用户单一进程同时可打开文件数量是多少？

    使用命令 ulimit -n 可以看到系统对于单个进程的限制，即open files;   
    open files  (-n) 65535  : 表示当前登录的用户，每个进程可以打开65535个句柄,当然总和不能超过 file-max 限制;   
    
#### 什么是并行，什么是并发？  
   
    并发:一个处理器同时处理多个任务。  
    并行:多个处理器或者是多核的处理器同时处理多个不同的任务.
![](https://ws3.sinaimg.cn/large/006tNc79gy1g54cte7ew5j31ky0fsq53.jpg)
    
#### 什么是同步，什么是异步，什么是堵塞，什么是非堵塞？
    同步:发出一个同步调用后，如果未得到结果，则一直等待，知道结果返回;  
    异步:发出一个异步调用后，该调用未立即得到结果，而程序继续运行；   
    例如:一个服务被分割为多个任务，服务获取的结果要求每个任务顺序执行，并依赖所有任务的执行结果，这种就是同步，如果该服务的结果不依赖所有的任务  
    则为异步;  
    阻塞: 服务依赖的某个任务执行完毕之前，工作线程一直在等待该任务返回的结果；  
    非阻塞: 服务不需要依赖任务执行完毕，工作线程就直接处理下一个任务；    
    简述:   
    同步：服务依赖任务的执行结果     
    异步：服务不依赖任务的执行结果   
    阻塞：服务执行时线程会出现等待状态     
    非阻塞：服务执行时线程不会出现等待状态      


#### 实现线程的三种方式？
     
    1,继承Thread: 定义一个继承Thead类的子类，子类重写Thread的run方法，然后实例化子类创建出线程对象，  
      然后调用线程对象的start()开启线程;        
    2,实现Runnable: 定义一个实现Runnable的实现类，实现类重写Runnable的run方法，然后实例出子类即线程对象，  
      然后调用线程对象的start()开启线程;    
    3,使用Callable和Future: 定义一个实现Callable的实现类，实现类重写Callable的call()方法,call()方法可以有返回值,    
      创建FutureTask对象,实例出实现类，用FutureTask对象包装实例出的实现类，FutureTask封装了Callable的call()的返回值;   
      通过new Thread(future).start的方式启动线程;

    
    

#### 线程的生命周期是什么？线程池的生命周期是什么？线程池的初始化的时候，池里面的线程处于生命周期的那个阶段？ --待解决

    线程的生命周期:  
    新建（New）-->就绪（Runnable）-->运行（Running）-->阻塞（Blocked）-->死亡(Dead)      
    1. 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值   
    2. 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行    
    3. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态   
    4. 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态   
    5. 在线程的生命周期当中，线程的各种状态的转换过程    
    ref:https://www.cnblogs.com/sunddenly/p/4106562.html   
    
    线程池的生命周期由5个状态值组成：      
    RUNNING：线程池可以接收任务，并且执行队列中的任务    
    SHUTDOWN：线程池不接收新任务，但是会执行队列中存储的任务    
    STOP：线程池不接收新任务，并且不会执行队列中的任务，同时打断正在执行的任务   
    TIDYING：所有任务都执行结束会切换到这个状态，同时 workCount(有效的线程个数)为0。      
    TERMINATED：terminated() 执行完成      
    ref:http://objcoding.com/2019/04/25/threadpool-running/ 
    
##### 什么是线程组？其作用是什么？   
    
    线程组(ThreadGroup):    
    简单来说就是一个线程集合。线程组的出现是为了更方便地管理线程。    
    线程组是父子结构的，一个线程组可以集成其他线程组，同时也可以拥有其他子线程组。从结构上看，线程组是一个树形结构，   
    每个线程都隶属于一个线程组，线程组又有父线程组，这样追溯下去，可以追溯到一个根线程组——System线程组。   
    作用:    
    可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织。   
   
    ref:https://juejin.im/post/5ca33a0af265da30c1724a6e#%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%BB%8B%E7%BB%8D


##### ThreadLocal是用来解决共享资源的多线程访问的问题吗？

    threadlocal原理:   
    threadlocal其实是在每个线程中维护着一个ThreadLocalMap，该map是以当前线程为key，以set的value为value；     
    threadlocal的get或者set方法就是通过线程内部的ThreadlocalMap来进行对象的存取;     
    threadlocal本身并不存放值，他只是作为key能让线程从TheadlocalMap中获取value；   
    所以threadlocal能够实现线程间的数据隔离，获取当前线程的局部变量值，不受其他线程影响;    
    设计理念:   
    ThreadLocal的设计目的是实现在当前线程中有自己的变量，并不是为了解决高并发和共享变量的问题;  
    ref:https://juejin.im/post/5ac2eb52518825555e5e06ee#comment   
    

##### 每次使用完ThreadLocal，都调用它的remove()方法，为什么呢？

    由于ThreadLocal内部类ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。       
    ThreadLocalMap中只是key指定了弱引用，但是value并不是弱引用，而是强引用，当把threadlocal实例置为null以后,没有任何强引用     
    指向threadlocal实例,所以threadlocal将会被gc回收，,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后,    
    current thread就不会存在栈中,强引用断开！所以想要避免内存泄露就要手动remove()掉！    
    ref:ref:https://juejin.im/post/5ba9a6665188255c791b0520      
    
##### volatile的作用？   

    使用volatile修饰的变量实现线程同步，但是volatile修饰的变量不具备原子性和线程安全性;       

##### run方法是否可以抛出异常？如果抛出异常，线程的状态如何？

    run方法不可以抛出异常,如果抛出异常线程则会被终结，但主线程和其他线程不受影响;     
    ref:https://blog.csdn.net/u010853261/article/details/61419677     

##### 什么是隐式锁？什么是显式锁？什么是无锁？

    隐式锁：被synchronized关键字所修饰的方法或者代码块，因为使用Synchronized加锁，不需要显式的去执行加锁和解锁的过程，   
           都由底层的jvm来执行，所以叫隐式锁；   
    显式锁: java的concurrent包提供了lock接口，使用者可轮询，中断，定时锁操作，所有的加锁和解锁过程都是显式的，因此成为  
           显式锁；例如：ReentrantLock，ReentrantReadWriteLock等;   
    无锁:  java无锁的实现是通过CSA来实现的，该操作是原子性的；例如：java.util.concurrent包中AtomicBoolean、   
           AtomicInteger、AtomicIntegerArray、AtomicLong、AtomicReference、AtomicReferenceArray。       
           
##### 多线程之间是如何通信的？
* Java的内存模型是什么？
* 什么是原子操作？生成对象的过程是不是原子操作？
* CopyOnWrite机制是什么？
* 什么是CAS?
* 什么是AQS?
* Fail-Fast机制是多线程原因造成的吗？
* 为什么要用线程池？常见的线程池有哪些？
* 阻塞队列的常用方法？
* 为什么数组比链表随机访问速度会快很多呢？
* 什么时候用定时器，什么时候用延时队列？
* 堵塞队列的add，offer，put的区别？
* 线程的阻塞与挂起有什么区别？
* sleep的时候，是否会释放已经获得到锁？
* yield的作用是什么？
* join的作用？

* sleep方法和yield方法的区别？
* 什么时候会发生InterruptedException异常？
* 如何设计一个利用无锁来实现线程的安全？
* 隐式锁什么情况下会释放锁？
* 描述一下可重入的实现机制？
* 什么是内存可见性？什么是寄存器可见性？
* 什么是自旋？举例说明一下。自旋的后果是什么呢？
* notifyAll之后所有的线程都会在次抢夺锁，如果抢夺失败怎么办？
* 什么是内存栅栏？
* 什么是before-happen？

* 常见的限流算法有哪些？
* synchronized锁的范围有哪些？
* 为什么使用线程池技术？
* 常见的创建线程池的三种方式是什么？各有什么特点？
* 可缓存的线程池中多少秒未使用的线程将被移除？
* 线程池内部的核心队列什么？
* 线程池中控制线程创建数目的参数是什么？
* 线程池在什么情况下需要丢弃处理？
* 线程池任务拒绝策略有哪些？
* 创建线程池常用的堵塞队列有哪些？
* Future的主要功能是什么？
* FutureTask的结构关系？FutureTask如何使用呢？



#### 案例一
* 自我介绍及项目
* java的内存分区
* java对象的回收方式,回收算法
* CMS和G1了解吗，CMS解决什么问题，说一下回收的过程
* CMS回收停顿了几次？为什么要停顿两次.
* java栈什么时候回发生内存溢出，java堆呢？说一种场景（集合类持有对象）,集合类如何解决这个问题呢，用软引用和弱引用，再讲下这两个引用的区别
* java里的锁了解哪些，Lock和synchronized，他们的使用方式和实现原理有什么区别？
* synchronized升级的过程，偏向锁到轻量级锁再到重量级锁，他们是如何实现的，解决了哪些问题，什么时候发生锁升级
* tomcat了解吗,说下类加载结构
* 关于spring,spring 如何让A和B两个Bean按顺序加载
* 10亿数据去重


#### 案例二 
* 1.jvm内存模型，
* 2.Oom和stackOverFlow的差别，for循环一直创建线程并且run起来会报什么错，
* 3.线程安全，锁，
* 4.gc，
* 5.ConcurrentHashMap1.8，
* 6.Zookeeper，
* 7.Mysql引擎和索引，
* 8.分页查询效率问题，
* 9.还有现场coding，写一个函数，输入n，表示n对括号，返回复合规则的括号组合的数量，比如输入1，组合有()，那么返回就是1，输入是2，
    组合有()()、(())，那   么返回2，输入3，能有这些组合()()()，(())()，()(())，((()))，(()())，所以输出为5

