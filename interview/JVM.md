#### 说一下jvm的主要组成部分？及其作用？
    堆:  
    java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的  
    唯一目的就是存放对象实例;  几乎所有的对象实例都在这里分配内存;也是java垃圾收集器管理的主要区域;Java堆可使用-Xms -Xmx进行内存控制;  
    方法区:  
    方法区和堆一样也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据；方法区在JDK1.7
    版本及以前被称为永久代(用-XX:MaxPermSize来控制大小)，从JDK1.8永久代被移除，从JDK1.7版本之后，运行时常量池从方法区移到了堆上；   
    虚拟机栈:  
    虚拟机栈是线程私有的，它的生命周期和线程相同，虚拟机栈描述的是java方法执行的内存模型,每个方法在执行的时候都会创建一个栈帧来存储局部变量表，  
    操作数栈，动态链接，方法的出口等信息;每一个方法的调用和执行完成的过程都对应着一个栈帧在虚拟机栈中的入栈和出栈的过程；  
    本地方法栈:  
    本地方法栈和虚拟机栈的作用相似，只不过本地方法栈服务于虚拟机使用到的本地方法，而虚拟机栈服务于虚拟机执行的java方法;  
    程序计数器:  
    当前线程所执行的字节码的行号指示器，指示Java虚拟机下一条需要执行的字节码指令;  
    
#### 说一下jvm运行时数据区？
    线程私有区域:  
       程序计数器,虚拟机栈，本地方法栈;  
    共有区域:  
       堆，方法区；  

#### 说一下堆栈的区别？
    栈内存:  
    栈内存区域主要是存储局部变量，即凡是定义在方法内的变量都是局部变量，方法外的是全局变量(for循环里面的也是局部变量);局部变量的定义  
    一定是先有方法的入栈，每个变量都有自己的作用域，一旦该变量离开了作用域则立即被释放，栈内存的更新速度更快，因为局部变量的生命周期都很短；  
    堆内存：  
    堆内存区域主要是存放对象实体(数组/对象),即new建立的都存放于堆中,堆中存放的是实体，而实体用于封装多种数据，如果实体的数据消失了，那么该  
    实体还存在，还可以再次使用所以堆内存中的实体不会立即释放;但是栈中存放的是单个变量，变量消失了那就没了，堆中的实体释放依靠JVM的垃圾收集器  
    不定时的进行回收；  
    栈内存和堆内存的区别：  
    1，栈存储的是局部变量而堆存储的是实体；  
    2，栈内存的更新速度比堆内存快，因为局部变量的生命周期很短;  
    3，栈内存的局部变量的生命周期结束后立马会被释放，而堆内存的实体生命周期结束后由JVM的垃圾收集器不定时的进行回收;  
    ref:https://blog.csdn.net/pt666/article/details/70876410
    
#### 队列和栈是什么？有什么区别？
    栈:是一种后进者先出，先进者后出的数据结构，栈是一种操作受限的数据结构，它只允许在一段插入或者删除数据，入栈push()出栈pop()；  
    队列：是一种先进者先出的数据结构,入队列enqueue()将一个数据插入尾部,出队列dequeue()在头部取数据；  
    
#### 什么是双亲委派模型？
    类加载器: 根据类的全限定名称来将class文件加载到JVM虚拟机中;  
    双亲委派模型： 
    某个类加载器再收到加载类的请求时，它首先不会去尝试加载类，而是将将加载任务委托给父类加载器，依次类推，如果在父类加载器中可以完成加载任务，  
    则返回成功，如果父类加载器在搜索范围内找不到该类，即ClassNotFoundException，子加载器才去尝试加载任务;    
   
    如何实现一个双亲委派模型:  
    继承ClassLoader，ClassLoader中有三个方法：  
    1,loadClass()该方法是ClassLoader类默认实现的，在该方法中首先会判断指定的类是否已经被加载，如果被加载了就无需在此加载；如果还没有加载 
      则先判断是否有父类加载器，如果有则使用父类加载器parent.loadClass(name, false)或者使用findBootstrapClassOrNull(name);  
    2，findClass(),如果第一步中的父类加载器和bootstrap加载器都没有加载到该类，则使用当前类加载的findClass()来完成类加载;    
    3,defineClass(),如果第二步中读取一个指定的名称的类为字节数组的话，可以使用defineClass()该方法将字节数组转为Class对象；    
    ref:https://blog.csdn.net/huachao1001/article/details/52297075  
        https://blog.csdn.net/tang9140/article/details/42738433 
![](https://ws4.sinaimg.cn/large/006tKfTcgy1g1dmghb1z6j31gi0qugme.jpg)   


#### 说一下类加载的执行过程？
    类从加载进虚拟机的内存到卸载出内存为止，生命周期:  加载->验证->准备->解析->初始化->使用->卸载  
    加载的执行过程(装载)：  
    1,通过类的全限定名称来获取该类的二进制字节流;  
    2,将字节流所代表的静态存储结构转换为方法区的运行时数据结构；  
    3,在java堆中生成一个代表该类的class对象，作为方法区这些数据的访问入口;  
    相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，  
    因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过  
    定义自己的类加载器去控制字节流的获取方式。 
    ref:https://blog.csdn.net/boyupeng/article/details/47951037  
    

#### 怎么判断对象是否可以被回收？
     引用计数法：给对象添加一个计数器，当有地方引用该对象时就将计数器+1,引用失效时就-1,任何时刻计数器为0的情况都视为该对象不能再被使用的;  
               但是引用计数法难以解决对象之间的循环引用问题;  
     可达性分析算法：通过一系列可以作为GC Root的对象作为起点，从这个起点开始向下搜索，搜索的路径称为引用链，当某对象到达GC Root没有任何引用链  
                  时则视为该对象不可用；
                  能作为GC Root对象的条件是: 
                  1,虚拟机栈中(栈帧中的局部变量表)引用的对象；  
                  2,方法区中静态属性引用的对象;  
                  3,方法区中常量引用的对象;  
                  4,本地方法栈中JNI引用的对象;  
                   

#### java 中都有哪些引用类型？
    1,强引用:强引用是指在程序代码之中普遍存在的，例如Object obj=new Object(),只要该强引用存在，垃圾收集器就不会回收该对象;  
    2,软引用:用来描述一些还有用但是并非必须的对象，在系统将要发生OOM之前，将会把这些对象列进回收范围之内进行第二次回收；如果这次回收还没有  
            足够的内存时，才会抛出内存溢出异常;  
    3,弱引用:用来描述一些非必须的对象，它比软引用更弱一些，对于弱引用的对象只能生存到下一次GC之前，当垃圾收集器工作的时候，不管内存是否足够都会  
            对弱引用的对象进行回收；  
    4,虚引用:最弱的一种引用，虚引用的最大作用在于跟踪对象回收，清理被销毁对象的相关资源。  
    ref:http://www.importnew.com/20468.html

#### 说一下jvm 有哪些垃圾回收算法？
标记-清除算法： 该算法分为两部分，第一部分是标记，标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象;    
标记清除算法的缺点是标记和清除的效率都不高，而且清除后会产生大量的不连续的内存空间;  
![](https://ws3.sinaimg.cn/large/006tKfTcgy1g1giedvel2j310h0u0ac8.jpg)   
复制算法:  该算法会把JVM的内存分为两部分，一部分用于存储对象，另一部分空闲，当一部分内存用完的时候就把该部分内存中尚存活的对象移动到  
另一部分内存中；然后清理该该部分内存；  
复制算法太过于浪费内存，实际上能够使用的内存缩小为原来的一半;   
![](https://ws4.sinaimg.cn/large/006tKfTcgy1g1gij37eclj30z60sk76f.jpg)    
标记整理算法: 该算法分为两步骤，第一步标记出需要回收的对象，然后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存；
![](https://ws4.sinaimg.cn/large/006tKfTcgy1g1gipq04yxj310p0u0tao.jpg)
分代收集算法：把堆内存分为新生代和老年代，新生代又分为Eden区,from Survivor,to Survivor,一般新生代区的对象都是朝生夕灭的，每次  
只有少量的对象存活下来,因此新生代采用复制算法，只需要复制那些少量的对象来完成垃圾回收；而老年代区域的对象一般存活率比较高，  
所以采用标记整理的算法进行回收； 
![](https://ws2.sinaimg.cn/large/006tKfTcgy1g1giwo8cmtj311o0gy757.jpg)                
ref:https://mp.weixin.qq.com/s/H__cChHHyvGInQBnehmIxw?from=groupmessage&isappinstalled=0

#### 说一下 jvm 有哪些垃圾回收器？
* 新生代垃圾收集器：  
Serial收集器: 他是一个单线程的收集器，采用的是复制算法的收集器；只要Serial收集器在工作，必须暂停所有的工作线程等待Serial收集器运行完成；  
![](https://ws4.sinaimg.cn/large/006tKfTcgy1g1gjd44lc3j312c0dc76m.jpg)
ParNew:是Serial的多线程版本，它的回收策略,回收算法和Serial基本相同;但在单CPU的环境中绝对不会有比Serial收集器有更好的效果；  
它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。  
![](https://ws3.sinaimg.cn/large/006tKfTcgy1g1gjgc461zj31200dedii.jpg)
Parallel Scavenge收集器:该收集器是并行的多线程新生代收集器，他也是采用复制算法，Parallel Scavenge的关注点在于达到一个可控的吞吐量，而  
其他收集器主要关注尽可能的缩短垃圾回收时停顿的时间;  
* 老年代收集器:  
Serial Old是Serial的老年代版本，它同样也是单线程的收集器，采用`标记-整理`算法;它的工作流程与Serial收集器相同； 
Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用`标记-整理`算法，该算的工作流和Parallel Scavenge收集器一样，如下:  
![](https://ws3.sinaimg.cn/large/006tKfTcgy1g1gjr9knphj31220d80ve.jpg)
CMS(concurrent Mark Sweep)收集器： 该收集器是以获取最短的回收停顿时间为目的的收集器，采用`标记-清除`算法；适合追求响应速度的B/S服务;
![](https://ws1.sinaimg.cn/large/006tKfTcgy1g1gk5s6s55j312i0c2gp2.jpg)
G1收集器: 面向服务端应用的垃圾收集器;可以做到并行并发，分代收集，空间整合，可预测的停顿；  
对比:  
![](https://ws1.sinaimg.cn/large/006tKfTcgy1g1gk9rci44j31340qy76e.jpg)
ref:https://crowhawk.github.io/2017/08/15/jvm_3/


#### 详细介绍一下CMS垃圾回收器？
CMS的工作流程: 
1. 初始标记（CMS initial mark）:标记GC Root能关联到的对象，速度很快，但是需要"Stop The World";  
2. 并发标记（CMS concurrent mark）:并行执行GC Root Tracing，在整个过程中该步骤最耗时间；
3. 重新标记（CMS remark）:用于重复标记因为并发标记期间用户程序运行而造成的标记产生变动的那一部分对象的标记记录; 此步骤
   需要"Stop The World"; 但是停顿时间没有第一步长;  
4. 并发清除（CMS concurrent sweep）  
CMS优点: 并发收集，低停顿；
CMS缺点:     
   1. 对CPU资源比较敏感，因为CMS是面向并发的程序,在并发阶段，虽然不会停止用户线程，但是会占用一部分线程资源，从而导致应用程序变慢，降低吞吐量;  
   2. 无法处理浮动垃圾,即:CMS收集器在回收的时候仍有一部分用户线程在运行着，这也伴随着有新的垃圾不断产生，这一部分垃圾出现后CMS不能再次集中的进行  
      处理一次，只能等到下次GC时再进行回收，这一部分的垃圾就称为浮动垃圾；   
   3. 标记清除产生的空间碎片,空间碎片过多就会导致很多大对象分配内存的麻烦，从而出现老年代空间剩余，但是无法申请到连续的内存空间给大对象;  
ref:https://blog.csdn.net/zqz_zqz/article/details/70568819  
    https://crowhawk.github.io/2017/08/15/jvm_3/
![](https://ws1.sinaimg.cn/large/006tKfTcgy1g1gk5s6s55j312i0c2gp2.jpg)

#### 详细介绍一下G1垃圾回收器？
G1垃圾收集器的特点： 
1. 并行并发；   
2. 分代收集;   
3. 空间整合,G1从整体来看是通过`标记-整理`的算法，但从局部(两个Regiion之间)来看采用的是`复制`算法;  
4. 可预测的停顿,降低停顿时间对CMS和G1是共同点，但G1不仅降低了停顿时间，还能建立可预测的停顿时间模型;     
* G1收集器横跨整个堆内存:  
G1之前的垃圾收集器的收集范围都是针对整个新生代或者老年代的；而G1却不是这样，G1收集器将java的堆内存划分为多个大小相等的独立区域(Region)，虽然还保留着新生代和老年代的概念，但是新生代和老年代不存在物理隔离,他们都是一部分Region的集合;
* G1收集器建立可预测的时间模型:  
G1收集器可以避免在整个java堆中进行全区域的垃圾回收,G1中维护一个垃圾回收优先级列表，每次根据允许的收集时间，回收最大价值的Region(Garbage First),这种使用Region划分内存空间并且根据优先级的区域回收方式，保证了G1收集器在有限的时间内能获得最大的回收效率;  
* G1的避免全堆扫描——Remembered Set：  
G1把整个java堆划分成了多个Region,但是对象被分配在一个Region中可以与堆中的任意对象有引用关系，所以在做可达性分析时为了确定某个对象是否存活的时候需要扫描整个heap区域,为了避免这样的事情发生，虚拟机为G1的每个Region维护了一个与之对应的Remembered Set；这样便可以把一个对象所属的Region之外的引用信息记录在被引用对象的Remembered Set中,当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。
* G1垃圾收集运行过程(不包含维护Rememberd Set):
1. 初始标记:需要停顿线程，但是耗时很短； 
2. 并发标记:GC Root的可达性分析，耗时较长,但是可与用户线程同时执行; 
3. 最终标记:为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，但是可并行执行; 
4. 筛选回收: 对各个Region的回收价值进行排序,筛选出最具有价值的Region进行回收; 
ref:https://crowhawk.github.io/2017/08/15/jvm_3/
![](https://ws1.sinaimg.cn/large/006tKfTcly1g1hobryps1j312s0ciq69.jpg)


#### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
    新生代: Serial,ParNew,Parallel Scavenge     
    老年代: Serial Old,Parallel Old,CMS  
    
    区别:  
    新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。  
    老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收  
    集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。  

#### 垃圾收集器总结
1. Serial收集器：单线程，垃圾回收时需要停下所有的线程工作。
2. ParNew收集器：Serial的多线程版本。
3. Parallel Scavenge收集器：年轻代，多线程并行收集。设计目标是实现一个可控的吞吐量（cpu运行代码时间/cpu消耗的总时间）。
4. Serial Old收集器：Serial老年代版本。
5. CMS：目标是获得最短回收停顿时间，基于标记清除算法，整个过程四个步骤：初始标记（标记GCRoot直接关联对象，速度很快）、并发标记（从GCRoot向下标记）、重新标记（并发标记过程中发生变化的对象）、并发清除（清除老年代垃圾）。初始标记和重新标记需要停顿所有用户线程。缺点：无法处理浮动垃圾、有空间碎片的产生、对CPU敏感。
6. G1收集器：唯一一个可同时用于老年代与新生代的收集器。采用标记整理算法，将堆分为不同大小星等的Region，G1追踪每个region的垃圾堆积的价值大小，然后有一个优先列表，优先回收价值最大的region，避免在整个堆中进行安全区域的垃圾收集，能建立可预测的停顿时间模型。整个过程四个步骤：初始标记、并发标记、最终标记（并发标记阶段发生变化的对象的变化记录写入线程remembered set log，同时与remembered set合并）、筛选回收（对每个region回收价值和成本拍寻，得到一个最好的回收方案并回收）。

#### JVM变量存储位置
    ref:https://blog.csdn.net/shanchahua123456/article/details/79605433

* 简述分代垃圾回收器是怎么工作的？
* 说一下 jvm 调优的工具？
#### 常用的 jvm 调优的参数都有哪些？
https://mp.weixin.qq.com/s/tfyHwbsNCTjvMGTrfQ0qwQ
#### JVM参数详细
https://mp.weixin.qq.com/s/tfyHwbsNCTjvMGTrfQ0qwQ
#### 参考:
https://juejin.im/post/5c875fb96fb9a049a82029b4
